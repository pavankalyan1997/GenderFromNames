# -*- coding: utf-8 -*-
"""GenderNamesClassification

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QMrVEVVX9VmD7EqyFbej8rcOw6T3--ZR
"""

from google.colab import drive
drive.mount('/content/drive')

!ls "/content/drive/My Drive/Colab Notebooks/GenderDataset"

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

!pip install --upgrade -q gspread

import gspread
import pandas as pd
from google.colab import auth
from oauth2client.client import GoogleCredentials

auth.authenticate_user()
gc = gspread.authorize(GoogleCredentials.get_application_default())

worksheet = gc.open('name_gender.csv').sheet1
rows = worksheet.get_all_values()

dataset=np.array(rows)

dataset.shape

dataset[0]

names=dataset[:,0]
names.shape

names=names[1:]

names[0]
names.shape

MAX_LEN=np.max([len(s) for s in names])
print(MAX_LEN)

gender=dataset[:,1]

gender=gender[1:]

gender[0]

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(names,gender,test_size=0.1,random_state=0)

print(X_train.shape)
print(y_train.shape)

print(X_test.shape)
print(y_test.shape)

X_train[0:20]

y_train[0:20]

X_test[0:20]

y_test[0:20]

X_train_lower=np.array([x.lower() for x in X_train])
X_test_lower=np.array([x.lower() for x in X_test])

print(X_train_lower[0:20])

vocabLength=27
vocab={}
for i in range(0,vocabLength):
  vocab[chr(i+97)] = i
print(vocab)

def convertNameToVec(name):
  vector=np.zeros((MAX_LEN,vocabLength))
  for i in range(min(MAX_LEN,len(name))):
    vec = np.zeros(vocabLength)
    vec[vocab[name[i]]] = 1
    vector[i,:] = vec
  return vector

print(convertNameToVec('pavan'))

X_train_converted=np.array([convertNameToVec(x) for x in X_train_lower])
X_test_converted=np.array([convertNameToVec(x) for x in X_test_lower])
print(X_train_converted.shape)
print(X_test_converted.shape)

y_train_oh=1*(y_train=='M')
y_test_oh=1*(y_test=='M')

X_train_converted,X_val_converted,y_train_oh,y_val_oh=train_test_split(X_train_converted,y_train_oh,test_size=0.1,random_state=0)

print(X_train_converted.shape)
print(X_val_converted.shape)
print(X_test_converted.shape)

print(y_train_oh.shape)
print(y_val_oh.shape)
print(y_test_oh.shape)

print(y_train_oh[0:20])
print(y_val_oh[0:20])
print(y_test_oh[0:20])

import keras.backend as K
from keras import layers
import tensorflow as tf
import warnings
warnings.filterwarnings("ignore")
import keras

from keras.layers import Input, Add, Dense, Activation, Flatten, Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D
from keras.models import Model, load_model
from keras.models import Sequential
from keras.layers import Dense, Dropout
from keras.layers import Embedding
from keras.layers import LSTM

hiddenlayer1 = 32
hiddenlayer2 = 8
numclasses = 2

def LSTM_Model():
  model=Sequential()
  model.add(LSTM(vocabLength,input_shape=(15, 27)))#,return_sequences=True
  model.add(Dropout(0.5))
  #model.add(LSTM(vocabLength))
  #model.add(Dropout(0.5))
  model.add(Dense(1, activation='sigmoid'))
  return model

tf.reset_default_graph()
model = LSTM_Model()
model.summary()

INIT_LR = 0.05  # initial learning rate
BATCH_SIZE = 128
EPOCHS = 25

tf.reset_default_graph()

model = LSTM_Model()

model.compile(
    loss='binary_crossentropy',  # we train 10-way classification
    optimizer=keras.optimizers.adamax(lr=INIT_LR),  # for SGD
    metrics=['accuracy']  # report accuracy during training
)

def lr_scheduler(epoch):
    return INIT_LR * 0.9 ** epoch

class LrHistory(keras.callbacks.Callback):
    def on_epoch_begin(self, epoch, logs={}):
        print("Learning rate:", K.get_value(model.optimizer.lr))

model_filename = 'lstmModel.{0:03d}.hdf5'
last_finished_epoch = None

history=model.fit(
    X_train_converted, y_train_oh,  # prepared data
    batch_size=BATCH_SIZE,
    epochs=EPOCHS,
    validation_data=(X_val_converted, y_val_oh),
    callbacks=[keras.callbacks.LearningRateScheduler(lr_scheduler), 
               LrHistory()],
    shuffle=True,
    verbose=1,
    initial_epoch=last_finished_epoch or 0
)

print(history.history.keys())
# summarize history for accuracy
plt.plot(history.history['acc'])
plt.plot(history.history['val_acc'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()
# summarize history for loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

y_pred_test = model.predict_proba(X_test_converted)
y_pred_test_classes=1*(y_pred_test>0.5)

y_pred_test_classes[0]

y_test_oh[1]

from sklearn.metrics import confusion_matrix, accuracy_score
print("Test accuracy:", accuracy_score(y_test_oh, y_pred_test_classes))

confusion_matrix(y_test_oh, y_pred_test_classes)

def predictGender(name):
  customNameVector=convertNameToVec(name.lower())
  customNameVector=customNameVector[np.newaxis,:,:]
  if(model.predict_proba(customNameVector)[0]>0.5):
    print('Male')
  else:print('Female')

predictGender('Pavan')

predictGender('Harika')

predictGender('Chuck')

predictGender('Likith')

predictGender('Krishna')#wrong prediction

predictGender('pradeep')

predictGender('vasanth')

predictGender('scarlett')

predictGender('chris')

predictGender('Warner')

predictGender('DevadasChirakal')

predictGender('AnuradhaBhagat')

predictGender('Vindhya')

predictGender('Vraksha')

predictGender('Carlos')

predictGender('Abhinaya')

predictGender('karthik')

predictGender('Akhil')

predictGender('Akhila')

predictGender('nishit')

predictGender('CMurali')

predictGender('PVRama')

predictGender('RobertDowny')

predictGender('MarkRuffalo')

predictGender('JoeSaldana')

predictGender('BenidictCumberbatch')

predictGender('Kit')#You know Nothing jon snow

predictGender('Shruti')

predictGender('PiyushDash')

predictGender('Prashanth')

#Saving model
from keras.models import model_from_json
#convert model to json
model_json = model.to_json()
with open("model.json", "w") as json_file:
    json_file.write(model_json)
    
model.save_weights("/content/drive/My Drive/Colab Notebooks/GenderDataset/genderModel.h5")
print("Saved model to disk")

# later...
 
# load json and create model
json_file = open('model.json', 'r')
loaded_model_json = json_file.read()
json_file.close()
loaded_model = model_from_json(loaded_model_json)
# load weights into new model
loaded_model.load_weights("/content/drive/My Drive/Colab Notebooks/GenderDataset/genderModel.h5")
print("Loaded model from disk")

# evaluate loaded model on test data
loaded_model.compile(loss='binary_crossentropy', optimizer=keras.optimizers.adamax(lr=0.05), metrics=['accuracy'])
score = loaded_model.evaluate(X_test_converted, y_test_oh, verbose=0)
print("%s: %.2f%%" % (loaded_model.metrics_names[1], score[1]*100))

def predictGenderFromLoadedModel(name):
  customNameVector=convertNameToVec(name.lower())
  customNameVector=customNameVector[np.newaxis,:,:]
  if(loaded_model.predict_proba(customNameVector)[0]>0.5):
    print('Male')
  else:print('Female')

predictGenderFromLoadedModel('RajaSekhar')

